#!/bin/bash

# Function to display the help message
show_help() {
    echo "Usage: $0 [-r depth] <server_ip> or $0 [-r depth] <file_with_ips>"
    echo ""
    echo "Options:"
    echo "  -r depth     Recursively list directories up to the specified depth."
    echo "  -h, --help   Show this help message and exit."
    echo ""
    echo "Examples:"
    echo "  $0 192.168.20.153"
    echo "  $0 -r 2 192.168.20.153"
    echo "  $0 -r 1 ips.txt"
    echo ""
    echo "Description:"
    echo "This script connects to SMB shares on a specified server (or list of servers)"
    echo "and lists the directories within those shares. It can optionally recurse"
    echo "into subdirectories up to a specified depth."
}

# Function to list folders recursively in a share
list_folders_recursive() {
    local share=$1
    local output_file=$2
    local depth=$3
    local current_depth=$4
    local path=$5

    # List the current directory
    smbclient "//$SERVER/$share" -U "$USER%$PASSWORD" -m SMB2 << EOF | grep -v "NT_STATUS_ACCESS_DENIED" | tee -a "$output_file"
    cd $path
    ls
    quit
EOF

    # If the current depth is less than the maximum depth, recurse into subdirectories
    if [ $current_depth -lt $depth ]; then
        local subfolders=$(smbclient "//$SERVER/$share" -U "$USER%$PASSWORD" -m SMB2 << EOF | grep "^  D" | awk '{print $1}'
        cd $path
        ls
        quit
EOF
)
        for subfolder in $subfolders; do
            echo -e "\e[33mEntering $subfolder in $share...\e[0m" | tee -a "$output_file"
            list_folders_recursive "$share" "$output_file" "$depth" $((current_depth + 1)) "$path/$subfolder"
        done
    fi
}

# Function to process each share
list_folders() {
    local share=$1
    local output_file=$2
    local depth=$3

    echo -e "\e[34mConnecting to $share...\e[0m" | tee -a "$output_file"

    if [ $depth -gt 0 ]; then
        list_folders_recursive "$share" "$output_file" "$depth" 1 ""
    else
        smbclient "//$SERVER/$share" -U "$USER%$PASSWORD" -m SMB2 << EOF | tee -a "$output_file"
        ls
        quit
EOF
    fi
}

# Function to process each IP
process_ip() {
    local SERVER=$1
    local depth=$2
    local output_file="sharelist_scan_results/scan_results_$SERVER.txt"
    local temp_output_file=$(mktemp)

    echo -e "\e[32mScanning $SERVER...\e[0m"

    # Test the connection and check for authentication errors
    smbclient -L //$SERVER -U "$USER%$PASSWORD" -m SMB2 2>/dev/null
    if [ $? -ne 0 ]; then
        echo -e "\e[31mError: Authentication failed for $SERVER. Please check your username and password.\e[0m"
        return
    fi

    # List shares and filter out unnecessary lines and those with a '$'
    shares=$(smbclient -L //$SERVER -U "$USER%$PASSWORD" -m SMB2 2>/dev/null | grep "Disk" | grep -v '\$' | awk '{print $1}')

    # Check if any shares were found
    if [ -z "$shares" ]; then
        echo -e "\e[31mNo non-administrative shares found on $SERVER. This could be due to incorrect authentication.\e[0m"
        return
    fi

    echo -e "\e[32mAvailable non-administrative shares on $SERVER:\e[0m" | tee -a "$temp_output_file"
    echo "$shares" | tee -a "$temp_output_file"

    local share_found=false

    # Connect to each share and list folders
    for share in $shares; do
        list_folders "$share" "$temp_output_file" "$depth" | grep -v "NT_STATUS_ACCESS_DENIED" || echo -e "\e[31mAccess denied for $share, skipping...\e[0m"
        share_found=true
    done

    if [ "$share_found" = true ]; then
        echo -e "\e[32mFinished checking all shares on $SERVER.\e[0m" | tee -a "$temp_output_file"
        mv "$temp_output_file" "$output_file"
    else
        rm "$temp_output_file"
    fi
}

# Main script logic

# Check if no arguments or help flag is provided
if [ -z "$1" ] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    show_help
    exit 0
fi

# Parse the arguments for recursive depth
depth=0
if [ "$1" == "-r" ]; then
    if [ -z "$2" ] || ! [[ "$2" =~ ^[0-9]+$ ]]; then
        echo -e "\e[31mError: Please provide a valid depth value after -r.\e[0m"
        show_help
        exit 1
    fi
    depth=$2
    shift 2
fi

# Create the output directory if it doesn't exist
output_dir="sharelist_scan_results"
mkdir -p "$output_dir"

# Server login information
USER="domain\\user"
PASSWORD='Password123!'

# Check if the argument is a file or an IP
if [ -f "$1" ]; then
    # Process each IP in the file
    while IFS= read -r SERVER; do
        if [ -n "$SERVER" ]; then
            process_ip "$SERVER" "$depth"
        fi
    done < "$1"
elif [[ "$1" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    # Process a single IP
    SERVER="$1"
    process_ip "$SERVER" "$depth"
else
    echo -e "\e[31mError: Invalid IP address or file path.\e[0m"
    show_help
    exit 1
fi

