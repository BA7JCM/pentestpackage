#!/bin/bash

# Define colors for output
ORANGE='\033[0;33m'
YELLOW='\033[1;33m'  # Adding yellow for highlighted messages
GREEN='\033[0;32m'
NC='\033[0m' # No Color

# Path to the log directory
LOG_DIR="/usr/share/responder/logs"

# Path to the sound file
SOUND_FILE="/usr/share/sounds/found.wav"

# Temporary directory to keep track of the current log states
TEMP_DIR="/tmp/log_backups"

# Directory to keep track of usernames seen
SEEN_DIR="/tmp/seen_usernames"

# Ensure the temporary directories exist
mkdir -p $TEMP_DIR
mkdir -p $SEEN_DIR

# Usage function
function usage() {
    echo "Usage: $0 --live | -L | --analyse | -A [--verbose | -V]"
    echo "  --live, -L     Monitor log files for live changes and alert new unique usernames."
    echo "  --analyse, -A  Analyse logs to print unique entries based on the first field."
    echo "  --verbose, -V  Show additional details such as the file names from which entries are found (only for --analyse)."
    exit 1
}

# Check if alsa-utils is installed (aplay is part of alsa-utils)
function check_alsa_utils() {
    if ! command -v aplay >/dev/null 2>&1; then
        echo -e "${RED}alsa-utils is not installed. aplay is required to play sound.${NC}"
        read -p "Do you want to install alsa-utils? (y/n) " yn
        case $yn in
            [Yy]* ) sudo apt-get install alsa-utils;;
            [Nn]* ) echo "Exiting script as aplay is required."; exit 1;;
            * ) echo "Please answer yes or no."; exit 1;;
        esac
    fi
}

VERBOSE=false

# Parse command-line arguments
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --live|-L) MODE="live"; shift ;;
        --analyse|-A) MODE="analyse"; shift ;;
        --verbose|-V) VERBOSE=true; shift ;;
        *) echo "Unknown parameter passed: $1"; usage; exit 1 ;;
    esac
done

case "$MODE" in
    "live")
        echo -e "${YELLOW}Monitoring for live changes...${NC}"
        # Populate seen files with current entries
        for file in $LOG_DIR/*.txt; do
            seen_file="$SEEN_DIR/$(basename "$file").seen"
            touch "$seen_file"  # Ensure seen file exists
            grep -vE '\$' "$file" | cut -d ':' -f 1 | sort | uniq > "$seen_file" 2>/dev/null
        done
        while true; do
            # Process each log file
            for file in $LOG_DIR/*.txt; do
                temp_file="$TEMP_DIR/$(basename "$file")"
                seen_file="$SEEN_DIR/$(basename "$file").seen"

                # Get current entries and update the temp file
                grep -vE '\$' "$file" > "$temp_file" 2>/dev/null

                # Compare current entries with seen file and process new entries
                newentries=$(comm -23 <(sort "$temp_file" 2>/dev/null) <(sort "$seen_file" 2>/dev/null))

                # Process new entries
                if [ ! -z "$newentries" ]; then
                    echo "$newentries" | while IFS= read -r line; do
                        username=$(echo "$line" | cut -d ':' -f 1)
                        if ! grep -qx "$username" "$seen_file"; then
                            echo "$username" >> "$seen_file"
                            # Play the notification sound
                            aplay $SOUND_FILE > /dev/null 2>&1
                            # Notify user of new entry
                            echo -e "${ORANGE}New entry found in \"$file\":${NC}"
                            echo -e "${GREEN}$line${NC}"
                        fi
                    done
                fi
            done
            # Wait before checking again
            sleep 10
        done
        ;;
    "analyse")
    echo -e "${YELLOW}Analysing logs for unique entries...${NC}"
    if [ "$VERBOSE" = true ]; then
        # Verbose output with proper handling of files and entries
        for file in $LOG_DIR/*.txt; do
            # Prepare and process the entries from the file
            entries=$(grep -vE '\$' "$file" | awk -F: '!seen[$1]++ {print $0}' 2>/dev/null)

            # Check if there are any entries to display
            if [[ -n "$entries" ]]; then
                echo -e "${ORANGE}Found in: $(basename "$file")${NC}"
                while IFS= read -r line; do
                    username="${line%%:*}"  # Extract username before the first colon
                    rest="${line#*:}"       # Get the rest of the line after the first colon
                    echo -e "${GREEN}${username}${NC}:${rest}"
                done <<< "$entries"
            fi
            unset seen  # Reset the seen array for the next file
        done
    else
        # Non-verbose output
        cat $LOG_DIR/*.txt | grep -vE '\$' | awk -F: '!seen[$1]++' | while IFS= read -r line; do
            username="${line%%:*}"  # Extract username before the first colon
            rest="${line#*:}"       # Get the rest of the line after the first colon
            echo -e "${GREEN}${username}${NC}:${rest}"
        done
    fi
    ;;

    *)
        usage
        ;;
esac
