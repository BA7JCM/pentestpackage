import os
import re
from termcolor import colored


def parse_testssl_output(content: str) -> dict:
    # Try to extract host and port
    host_match = re.search(r"-->> (.*?):(\d+)", content)
    if not host_match:
        print(colored(f"[WARNING] Couldn't extract host and port from content:\n{content[:1000]}", "yellow"))
        return {}

    host, port = host_match.groups()
    cipher_details = re.findall(r"(\w+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(TLS_\S+)", content)
    cipher_data = {f"{host}:{port} (TCP)": {}}

    for detail in cipher_details:
        hexcode, cipher_name_openssl, key_exchange, encryption, bits, cipher_name_iana = detail
        protocol = cipher_name_iana.split("_")[1]
        cipher_data[f"{host}:{port} (TCP)"].setdefault(protocol, []).append(cipher_name_openssl)

    return cipher_data



def process_testssl_directory(directory: str) -> dict:
    aggregated_data = {}
    
    # Debug code to print all files in directory
    print("[DEBUG] Files in the directory:")
    for filename in os.listdir(directory):
        filepath = os.path.join(directory, filename)
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as file:
            content = file.read()
            print(f"--- {filename} ---")
            print(content[:500])  # Printing the first 500 characters for brevity
            print("-------------------")
    
    for filename in os.listdir(directory):
        if filename.endswith('.txt') and "testssl.sh" in filename:  # Only process .txt files that contain 'testssl.sh' in their name
            filepath = os.path.join(directory, filename)
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as file:
                content = file.read()
                file_data = parse_testssl_output(content)
                aggregated_data.update(file_data)
    return aggregated_data



def generate_html_tables_from_parsed_data(data: dict) -> str:
    html_content = '<html><head><style>table, th, td {border: 1px solid black; border-collapse: collapse;}</style></head><body>'

    for host, protocols in data.items():
        html_content += f"<h2>{host}</h2>"
        html_content += "<table>"
        html_content += "<tr><th>Protocol</th><th>Cipher Suite</th></tr>"
        
        for protocol, ciphers in protocols.items():
            html_content += f"<tr><td rowspan='{len(ciphers)}'>{protocol}</td><td>{ciphers[0]}</td></tr>"
            for cipher in ciphers[1:]:
                html_content += f"<tr><td>{cipher}</td></tr>"

        html_content += "</table><br><br>"

    html_content += "</body></html>"
    return html_content


def generate_tls_cipher_tables(working_directory, input_filename):
    print(colored("\n[DEBUG] Entering the generate_tls_cipher_tables function...", "yellow"))
    try:
        directory = os.path.join(working_directory, f"{input_filename}-attackmodule-tlsanalysis")
        aggregated_data = process_testssl_directory(directory)

        if not aggregated_data:
            print(colored("\n[WARNING] No valid data found. Skipping HTML generation.", "yellow"))
            return

        html_content = generate_html_tables_from_parsed_data(aggregated_data)
        output_file = os.path.join(directory, "cipher_tables.html")
        
        with open(output_file, 'w') as file:
            file.write(html_content)
        
        print(colored(f"\nHTML table has been created for the ciphers and vulnerabilities at: {output_file}\n", "green"))
    except Exception as e:
        print(colored(f"\nError occurred while generating the HTML table: {str(e)}\n", "red"))

