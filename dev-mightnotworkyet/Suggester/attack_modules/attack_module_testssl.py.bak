import subprocess
import os
import requests
import re
from datetime import datetime
from termcolor import colored
from tqdm import tqdm
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import ipaddress
from tabulate import tabulate
import pandas as pd
from multiprocessing import Pool
from attack_modules.attack_module_testssl_ciphers_table import generate_tls_cipher_tables




WEB_SERVICES = ["http", "https"]

# Suppress only the single InsecureRequestWarning from urllib3
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

def is_ip(address):
    """Check if the given address is an IP."""
    try:
        ipaddress.ip_address(address)
        return True
    except ValueError:
        return False

def log_error(error_message, log_file_path):
    with open(log_file_path, 'a') as f:
        f.write(f"{datetime.now()} - {error_message}\n")

def colorize_protocol(protocol):
    """Color the protocol based on its security."""
    RED = '\033[91m'
    GREEN = '\033[92m'
    END = '\033[0m'

    if protocol in ["SSLv2", "SSLv3", "TLS 1.0", "TLS 1.1"]:
        return f"{RED}{protocol}{END}"
    elif protocol in ["TLS 1.2", "TLS 1.3"]:
        return f"{GREEN}{protocol}{END}"
    else:
        return protocol

def remove_ansi_codes(text):
    """Remove ANSI color codes from a given text."""
    ansi_escape = re.compile(r'\x1B\[[0-?]*[ -/]*[@-~]')
    return ansi_escape.sub('', text)

def extract_summary_from_testssl(output_path):
    """Parse the testssl.sh output and extract summary details."""
    protocols = []
    vulnerabilities = []

    with open(output_path, 'r') as f:
        lines = f.readlines()

        # Extract protocols
        is_in_protocols_section = False
        for line in lines:
            if "Testing protocols via sockets except NPN+ALPN" in line:
                is_in_protocols_section = True
                continue
            if "NPN/SPDY" in line or "ALPN/HTTP2" in line:
                is_in_protocols_section = False
            
            if is_in_protocols_section and "offered" in line and "not" not in line:
                protocol = " ".join(line.split()[:2])
                if protocol == "TLS 1":
                    protocol = "TLS 1.0"
                protocols.append(colorize_protocol(protocol))
            
            # Extract vulnerabilities
            if 'VULNERABLE' in line:
                vulnerability_name = line.split()[0]
                if vulnerability_name != "VULNERABLE":
                    vulnerabilities.append(vulnerability_name)
    
    return protocols, vulnerabilities

def run_testssl_scan(args):
    address, port, testssl_path, working_directory, input_filename, errors_log_path = args
    summary = []
    headers = {}
    url_scheme = "https" if port in ['443', '4433'] else None
    if not url_scheme:
        return summary
    try:
        with requests.Session() as session:
            response = session.get(f'{url_scheme}://{address}:{port}', timeout=15, verify=False)
        if not (200 <= response.status_code < 400):
            log_error(f"Service on {address}:{port} responded with an error: {response.status_code} {response.reason}", errors_log_path)
            return summary
    except requests.RequestException as e:
        log_error(f"Error checking service on {address}:{port} - {str(e)}", errors_log_path)
        return summary
    current_time = datetime.now().strftime('%H-%M-%S')
    output_path = f"{working_directory}/{input_filename}-attackmodule-tlsanalysis/tlsanalysis_{address}_{port}_{current_time}.txt"
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    command = ["/bin/bash", testssl_path, "--color", "0", '-U', '-E', '--each-cipher', '--protocols', '--logfile', output_path, f"{address}:{port}"] # Moved f"{address}:{port}" to the end
    try:
        subprocess.run(command, capture_output=True, check=True, text=True)
        protocols, vulnerabilities = extract_summary_from_testssl(output_path)
        summary.append([f"{address}:{port}", ', '.join(protocols), ', '.join(vulnerabilities)])
    except subprocess.CalledProcessError as e:
        log_error(f"Service on {address}:{port} encountered an error during testssl analysis. Error: {str(e)}\n{e.stderr}", errors_log_path)
    return summary


def tls_analysis(data, working_directory, input_filename):
    testssl_path = "./resources/testssl.sh/testssl.sh"
    if not os.path.exists(testssl_path):
        print(colored("Error: testssl.sh not found. Ensure it's located in './resources/testssl.sh/'", "red"))
        return
    https_services = data[(data['service'].isin(WEB_SERVICES)) | (data['port'].astype(str).isin(['80', '443', '4433']))]
    errors_log_path = os.path.join(working_directory, f"{input_filename}-testssl-errors.log")
    print(colored(f"Identified {len(https_services)} potential HTTPS services.", "yellow"))
    args_list = [(row['ip'], row['port'], testssl_path, working_directory, input_filename, errors_log_path) for _, row in https_services.iterrows()]
    with Pool(5) as p:  # 5 is the number of processes
        results = list(tqdm(p.imap(run_testssl_scan, args_list), total=len(args_list), desc="Analyzing", ncols=100))
    summary_table = [item for sublist in results for item in sublist]
    if os.path.exists(errors_log_path):
        print(colored(f"\nDetailed errors have been logged to: '{errors_log_path}'.", "yellow"))
    summary_df = pd.DataFrame(summary_table, columns=["IP:PORT", "Protocols", "Vulnerabilities"]).drop_duplicates()
    summary_df['Protocols'] = summary_df['Protocols'].apply(remove_ansi_codes)
    summary_df['Vulnerabilities'] = summary_df['Vulnerabilities'].apply(remove_ansi_codes)
    print("\nSummary Table:")
    print(tabulate(summary_df.values, headers=["IP:PORT", "Protocols", "Vulnerabilities"]))
    timestamp = datetime.now().strftime('%Y-%m-%d')
    output_filename = os.path.join(working_directory, f"{input_filename}-attackmodule-tlsanalysis", f"tlsanalysis_summary_{timestamp}.csv")
    summary_df.to_csv(output_filename, index=False)
    print(f"\nSummary saved to {output_filename}")
    generate_tls_cipher_tables(working_directory, input_filename)
