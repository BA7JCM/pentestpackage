import os
import sys
import subprocess
import argparse
from datetime import datetime
from termcolor import colored
from utils import print_banner, check_requirements
from data_handlers import parse_csv, parse_xml, save_to_csv, apply_example_commands
from attack_modules.attack_module_screenshotter import screenshotter
from attack_modules.attack_module_testssl import tls_analysis
from attack_modules.attack_module_testssl_ciphers_table import generate_tls_cipher_tables

sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Define the debug mode flag
DEBUG_MODE = False

# Define a function for debug printing
def print_debug(message):
    if DEBUG_MODE:
        print(message)

# Add a list of required Python packages
REQUIRED_PYTHON_PACKAGES = [
    'selenium',
    'webdriver_manager',
    'tqdm',
    'ipaddress',
    'argparse',
    'termcolor'
]

# Add a function to check Python package installation
def is_package_installed(package):
    try:
        __import__(package)
        return True
    except ImportError:
        return False

# Add a function to check if Google Chrome is installed
def is_google_chrome_installed():
    try:
        subprocess.run(['google-chrome', '--version'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except FileNotFoundError:
        return False

# Function to install Python packages
def install_python_packages(packages):
    for package in packages:
        subprocess.run([sys.executable, '-m', 'pip', 'install', package])

# Function to install Google Chrome
def install_google_chrome():
    subprocess.run(['sudo', 'apt-get', 'install', 'google-chrome-stable'], check=True)

# Add a function to handle installation of missing requirements
def handle_missing_requirements():
    missing_packages = [pkg for pkg in REQUIRED_PYTHON_PACKAGES if not is_package_installed(pkg)]
    missing_chrome = not is_google_chrome_installed()

    if missing_packages or missing_chrome:
        print("The following Python packages are missing:", missing_packages)
        if missing_chrome:
            print("Google Chrome is not installed.")
        
        user_choice = input("Do you want to install the missing requirements? [Y/n]: ").lower()
        if user_choice == 'y':
            if missing_packages:
                install_python_packages(missing_packages)
            if missing_chrome:
                install_google_chrome()

# Check and install requirements at the beginning of the main function
def main():
    handle_missing_requirements()
    
    parser = argparse.ArgumentParser()
    parser.add_argument("file_path", help="Path to the input file containing service information.")
    parser.add_argument("-a", "--attack", help="Enable attack mode to run predefined attacks on detected services.", action="store_true")
    args = parser.parse_args()
    file_path = args.file_path

    # Determine file type based on content
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as file:
        initial_content = file.read(100)  # reading the first 100 characters
        if '<?xml' in initial_content:
            file_type = 'xml'
        elif ',' in initial_content:
            file_type = 'csv'
        else:
            print(colored("Error: Unrecognized file type. Please provide a valid CSV or XML file.", "red"))
            sys.exit(1)

    # Print the banner with attack_mode status
    print_banner(args.attack)

    # Parse the data based on the determined file type
    if file_type == 'csv':
        data = parse_csv(file_path)
    elif file_type == 'xml':
        data = parse_xml(file_path)

    # Rename the "address" column to "ip" if it exists
    if "address" in data.columns:
        data.rename(columns={"address": "ip"}, inplace=True)

    # Extracting the input filename without its extension
    input_filename = os.path.basename(file_path).split('.')[0]
    # Getting the current date
    current_date = datetime.now().strftime('%Y-%m-%d')
    # Constructing the desired directory name
    working_directory = f"Results-{input_filename}-{current_date}"

    if not os.path.exists(working_directory):
        os.makedirs(working_directory)

    # Apply example commands
    data_with_commands = apply_example_commands(data, file_path)

    # Save the results to a CSV (this step can be adjusted based on requirements)
    save_to_csv(data_with_commands, working_directory, input_filename)

    # If attack mode is enabled, execute the attack modules
    if args.attack:
        #print_debug("Debug: DataFrame columns are: " + str(data_with_commands.columns))
        run_attack_module(data_with_commands, working_directory, input_filename, "screenshotter", screenshotter)
        run_attack_module(data_with_commands, working_directory, input_filename, "testssl", tls_analysis)

def run_attack_module(data_with_commands, working_directory, input_filename, module_name, module_func):
    separator = "-" * 40
    print(colored("\n" + separator, "green"))  # Adding a newline for spacing
    print(colored(f"attack module: {module_name}", "green"))
    print(colored(separator, "green"))

    user_choice = input(colored(f"Do you want to run the {module_name} attack module? [Y/n]: ", "yellow"))
    if not user_choice or user_choice.lower() == 'y':
        print(colored(f"\nRunning attack module: {module_name}", "yellow"))
        module_func(data_with_commands, working_directory, input_filename)

if __name__ == '__main__':
    main()
