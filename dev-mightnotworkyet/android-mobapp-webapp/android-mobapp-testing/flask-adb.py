from flask import Flask, render_template, jsonify, request, stream_with_context, Response
import os
import subprocess
import tempfile
import time
import shutil
import xml.etree.ElementTree as ET
from threading import Thread

app = Flask(__name__)
UPLOAD_FOLDER = 'uploads'
ALLOWED_EXTENSIONS = {'apk'}

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

@app.errorhandler(404)
def page_not_found(e):
    return jsonify(error=str(e)), 404

@app.errorhandler(500)
def internal_server_error(e):
    app.logger.error(f"Internal server error: {str(e)}")
    return jsonify(error="Internal server error"), 500

@app.route('/')
def index():
    return render_template('index.html')

#### list devices #####
@app.route('/list-devices')
def list_devices():
    try:
        result = subprocess.run(['adb', 'devices'], capture_output=True, text=True)
        devices = result.stdout.split('\n')[1:-2]
        return {'devices': devices}
    except Exception as e:
        app.logger.error(f"Error fetching devices: {str(e)}")
        return jsonify(error=str(e)), 500


##### INSTALL APK #######
@app.route('/install-apk', methods=['POST'])
def install_apk():
    try:
        if 'apkFile' not in request.files:
            return jsonify(success=False, message="No file part")
        file = request.files['apkFile']
        if file.filename == '':
            return jsonify(success=False, message="No selected file")
        if file and file.filename.endswith('.apk'):
            filename = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
            file.save(filename)
            result = subprocess.run(['adb', 'install', filename], capture_output=True, text=True)
            if 'Success' in result.stdout:
                # Extract package name and version
                package_info = subprocess.run(['aapt', 'dump', 'badging', filename, '|', 'grep', "'package: name'", '|', 'sed', '-n', "s/.*versionName='\([^']*\)'.*/\1/p"], capture_output=True, text=True).stdout.strip()
                package_name = package_info.split(' ')[1].split("'")[1]
                version_name = package_info.split(' ')[3].split("'")[1]
                return jsonify(success=True, message="APK installed successfully!", packageName=package_name, versionName=version_name, apkFilename=file.filename)
            else:
                print("ADB Output:", result.stdout)
                print("ADB Error:", result.stderr)
                return jsonify(success=False, message="Failed to install APK.", adbOutput=result.stdout, adbError=result.stderr)
        return jsonify(success=False, message="Invalid file type.")
    except Exception as e:
        app.logger.error(f"Error during APK installation: {str(e)}")
        return jsonify(success=False, message=str(e)), 500

### UNISNTALL APK #######
@app.route('/uninstall-apk', methods=['POST'])
def uninstall_apk():
    try:
        package_name = request.form.get('packageName')
        print(f"Attempting to uninstall package: {package_name}")
        result = subprocess.run(['adb', 'uninstall', package_name], capture_output=True, text=True)
        if 'Success' in result.stdout:
            return jsonify(success=True, message=f"Uninstalled {package_name} successfully!")
        else:
            print("ADB Output:", result.stdout)
            print("ADB Error:", result.stderr)
            return jsonify(success=False, message=f"Failed to uninstall {package_name}.")
    except Exception as e:
        app.logger.error(f"Error during APK uninstallation: {str(e)}")
        return jsonify(success=False, message=str(e)), 500

##### ANALYSE APK #######
@app.route('/analyse-apk', methods=['POST'])
def analyse_apk():
    print("Entered the /analyse-apk route")
    try:
        apk_file_name = request.form.get('apkFileName')  # Retrieve the APK file name
        if not apk_file_name:
            return jsonify(status="error", message="APK file name not provided."), 400
        
        # Logging: Print the path you're trying to access
        apk_path = os.path.join(UPLOAD_FOLDER, apk_file_name)
        print(f"Trying to access APK at: {apk_path}")
        
        if not os.path.exists(apk_path):
            return jsonify(status="error", message=f"APK file '{apk_file_name}' not found."), 404

        decompiled_folder_name = os.path.splitext(apk_file_name)[0]  # Extract base name without extension
        decompiled_path = os.path.join(UPLOAD_FOLDER, "decompiled", decompiled_folder_name)

        # Check if the decompiled folder already exists, and if so, remove it to ensure a clean decompilation
        if os.path.exists(decompiled_path):
            shutil.rmtree(decompiled_path)

        # Run apktool to decompile the APK
        cmd = ["apktool", "d", apk_path, "-o", decompiled_path]
        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode != 0:
            return jsonify(status="error", message="Decompilation failed.", adbOutput=result.stdout, adbError=result.stderr), 500

        return jsonify(status="success", message="APK decompiled successfully!", decompiledPath=decompiled_path)
    except Exception as e:
        app.logger.error(f"Error during APK analysis: {str(e)}")
        return jsonify(status="error", message=str(e)), 500

        
##### LOG CAT CONSOLE #####

logcat_process = None
logs_buffer = []
should_fetch_logs = False

def run_logcat():
    global logcat_process
    global should_fetch_logs
    logcat_process = subprocess.Popen(['adb', 'logcat'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    for line in iter(logcat_process.stdout.readline, b''):
        if not should_fetch_logs:
            break
        logs_buffer.append(line)
        if len(logs_buffer) > 5000:  # Keeping only the last 5000 logs for memory efficiency
            logs_buffer.pop(0)

## START LOGCAT ##
@app.route('/start-logcat', methods=['GET'])
def start_logcat():
    global logcat_process
    global should_fetch_logs
    if logcat_process is None:
        should_fetch_logs = True
        Thread(target=run_logcat).start()
        return jsonify(success=True, message="Started logcat.")
    else:
        return jsonify(success=False, message="Logcat already running.")

## STOP LOGCAT ##
@app.route('/stop-logcat', methods=['GET'])
def stop_logcat():
    global logcat_process
    global should_fetch_logs
    should_fetch_logs = False
    if logcat_process:
        logcat_process.terminate()
        logcat_process = None
        return jsonify(success=True, message="Stopped logcat.")
    else:
        return jsonify(success=False, message="Logcat not running.")

# GET LOGS #
@app.route('/get-logs', methods=['GET'])
def get_logs():
    global logs_buffer
    return jsonify(logs=logs_buffer[-100:])  # Returning the last 100 logs

# CLEAR LOGS#
@app.route('/clear-logs', methods=['GET'])
def clear_logs():
    global logs_buffer
    logs_buffer = []
    return jsonify(success=True, message="Logs cleared.")


####### STATIC ANALYSIS #########
@app.route('/static-analysis', methods=['POST'])
def static_analysis():
    try:
        apk_name = request.form.get('apkName')  # Retrieve the APK name or identifier
        if not apk_name:
            return jsonify(status="error", message="APK name not provided."), 400

        decompiled_folder_name = os.path.splitext(apk_name)[0]  # Extract base name without extension
        decompiled_path = os.path.join(UPLOAD_FOLDER, "decompiled", decompiled_folder_name)

        vulnerabilities = []

        # Check for backups enabled in AndroidManifest.xml
        manifest_path = os.path.join(decompiled_path, "AndroidManifest.xml")
        if os.path.exists(manifest_path):
            tree = ET.parse(manifest_path)
            root = tree.getroot()
            application_element = root.find('application')
            if application_element is not None and application_element.get('android:allowBackup') == "true":
                vulnerabilities.append({
                    'id': 'backup_enabled',
                    'title': 'Backups Enabled',
                    'risk': 'low',
                    'color': 'green'
                })

        return jsonify(status="success", vulnerabilities=vulnerabilities)
    except Exception as e:
        app.logger.error(f"Error during static analysis: {str(e)}")
        return jsonify(status="error", message=str(e)), 500
#################################  

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0')
