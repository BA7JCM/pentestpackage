import subprocess
import os
import requests
import re
from datetime import datetime
from termcolor import colored
from tqdm import tqdm
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import ipaddress
from tabulate import tabulate
import pandas as pd

WEB_SERVICES = ["http", "https"]

# Suppress only the single InsecureRequestWarning from urllib3
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

def is_ip(address):
    """Check if the given address is an IP."""
    try:
        ipaddress.ip_address(address)
        return True
    except ValueError:
        return False

def log_error(error_message, log_file_path):
    with open(log_file_path, 'a') as f:
        f.write(f"{datetime.now()} - {error_message}\n")

def colorize_protocol(protocol):
    """Color the protocol based on its security."""
    RED = '\033[91m'
    GREEN = '\033[92m'
    END = '\033[0m'

    if protocol in ["SSLv2", "SSLv3", "TLS 1.0", "TLS 1.1"]:
        return f"{RED}{protocol}{END}"
    elif protocol in ["TLS 1.2", "TLS 1.3"]:
        return f"{GREEN}{protocol}{END}"
    else:
        return protocol

def remove_ansi_codes(text):
    """Remove ANSI color codes from a given text."""
    ansi_escape = re.compile(r'\x1B\[[0-?]*[ -/]*[@-~]')
    return ansi_escape.sub('', text)

def extract_summary_from_testssl(output_path):
    """Parse the testssl.sh output and extract summary details."""
    protocols = []
    vulnerabilities = []

    with open(output_path, 'r') as f:
        lines = f.readlines()

        # Extract protocols
        is_in_protocols_section = False
        for line in lines:
            if "Testing protocols via sockets except NPN+ALPN" in line:
                is_in_protocols_section = True
                continue
            if "NPN/SPDY" in line or "ALPN/HTTP2" in line:
                is_in_protocols_section = False
            
            if is_in_protocols_section and "offered" in line and "not" not in line:
                protocol = " ".join(line.split()[:2])
                if protocol == "TLS 1":
                    protocol = "TLS 1.0"
                protocols.append(colorize_protocol(protocol))
            
            # Extract vulnerabilities
            if 'VULNERABLE' in line:
                vulnerability_name = line.split()[0]
                if vulnerability_name != "VULNERABLE":
                    vulnerabilities.append(vulnerability_name)
    
    return protocols, vulnerabilities


def tls_analysis(data, working_directory, input_filename):
    testssl_path = "./resources/testssl.sh/testssl.sh"
    if not os.path.exists(testssl_path):
        print(colored("Error: testssl.sh not found. Ensure it's located in './resources/testssl.sh/'", "red"))
        return

    https_services = data[(data['service'].isin(WEB_SERVICES)) | (data['port'].astype(str).isin(['80', '443', '4433']))]
    errors_log_path = os.path.join(working_directory, f"{input_filename}-testssl-errors.log")

    print(colored(f"Identified {len(https_services)} potential HTTPS services.", "yellow"))

    summary_table = []

    for _, row in tqdm(https_services.iterrows(), total=len(https_services), desc="Analyzing", ncols=100):
        address, port, service = row['ip'], row['port'], row['service']

        headers = {}

        # Define the scheme based on the port and skip if it's port 80
        if port == '80':
            continue
        elif port in ['443', '4433']:
            url_scheme = "https"
        else:
            continue

        try:
            with requests.Session() as session:
                response = session.get(f'{url_scheme}://{address}:{port}', timeout=5, verify=False)
            
            if not (200 <= response.status_code < 400):
                log_error(f"Service on {address}:{port} responded with an error: {response.status_code} {response.reason}", errors_log_path)
                continue

        except requests.RequestException as e:
            log_error(f"Error checking service on {address}:{port} - {str(e)}", errors_log_path)
            continue

        current_time = datetime.now().strftime('%H-%M-%S')
        output_path = f"{working_directory}/{input_filename}-attackmodule-tlsanalysis/tlsanalysis_{address}_{port}_{current_time}.txt"
        os.makedirs(os.path.dirname(output_path), exist_ok=True)

        command = ["/bin/bash", testssl_path, "--color", "0", '-U', '-H', '-T', '-R', '-C', '-B', '-O', '-Z', '-W', '-A', '-L', '-WS', '-F', '-J', '-D', '--protocols', '--logfile', output_path, f"{address}:{port}"]

        try:
            subprocess.run(command, capture_output=True, check=True, text=True)
            protocols, vulnerabilities = extract_summary_from_testssl(output_path)
            summary_table.append([f"{address}:{port}", ', '.join(protocols), ', '.join(vulnerabilities)])

        except subprocess.CalledProcessError as e:
            log_error(f"Service on {address}:{port} encountered an error during testssl analysis. Error: {str(e)}\n{e.stderr}", errors_log_path)

    if os.path.exists(errors_log_path):
        print(colored(f"\nDetailed errors have been logged to: '{errors_log_path}'.", "yellow"))
    
    # Convert the summary table to a DataFrame and remove duplicates
    summary_df = pd.DataFrame(summary_table, columns=["IP:PORT", "Protocols", "Vulnerabilities"]).drop_duplicates()
    
    # Clean color codes for CSV
    summary_df['Protocols'] = summary_df['Protocols'].apply(remove_ansi_codes)
    summary_df['Vulnerabilities'] = summary_df['Vulnerabilities'].apply(remove_ansi_codes)
    
    print("\nSummary Table:")
    print(tabulate(summary_df.values, headers=["IP:PORT", "Protocols", "Vulnerabilities"]))

    # Save the summary to a CSV file
    timestamp = datetime.now().strftime('%Y-%m-%d')
    output_filename = os.path.join(working_directory, f"{input_filename}-attackmodule-tlsanalysis", f"tlsanalysis_summary_{timestamp}.csv")
    summary_df.to_csv(output_filename, index=False)
    print(f"\nSummary saved to {output_filename}")

