import subprocess
import os
import requests
from datetime import datetime
from termcolor import colored
from tqdm import tqdm
from requests.packages.urllib3.exceptions import InsecureRequestWarning

WEB_SERVICES = ["http", "https"]

# Suppress only the single InsecureRequestWarning from urllib3
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

def log_error(error_message, log_file_path):
    with open(log_file_path, 'a') as f:
        f.write(f"{datetime.now()} - {error_message}\n")

def tls_analysis(data, working_directory, input_filename):
    """
    Conducts a TLS analysis on identified HTTPS services.
    Uses the testssl.sh script for comprehensive TLS/SSL analysis.
    """

    testssl_path = "resources/testssl.sh/testssl.sh"
    if not os.path.exists(testssl_path):
        print(colored("Error: testssl.sh not found. Ensure it's located in 'resources/testssl.sh/'", "red"))
        return

    # Filter to get only the rows corresponding to web services (http & https)
    https_services = data[data['service'].isin(WEB_SERVICES)]
    errors_log_path = os.path.join(working_directory, f"{input_filename}-testssl-errors.log")

    print(colored(f"Identified {len(https_services)} potential HTTPS services.", "yellow"))

    for _, row in tqdm(https_services.iterrows(), total=len(https_services), desc="Analyzing", ncols=100):
        address, port, service = row['ip'], row['port'], row['service']

        # Skip the HTTPS check for services running on port 80
        if port == '80':
            continue

        try:
            # For HTTPS services, ignore certificate errors during the initial check
            response = requests.get(f'https://{address}:{port}', timeout=5, verify=False)
            
            # Consider any 2xx and 3xx response as a valid HTTPS service
            if not (200 <= response.status_code < 400):
                log_error(f"Service on {address}:{port} responded with an error: {response.status_code} {response.reason}", errors_log_path)
                continue

        except requests.RequestException as e:
            log_error(f"Error checking service on {address}:{port} - {str(e)}", errors_log_path)
            continue

        # If the service passes the initial checks, run testssl.sh
        current_time = datetime.now().strftime('%H-%M-%S')
        output_path = f"{working_directory}/{input_filename}-attackmodule-tlsanalysis/tlsanalysis_{address}_{port}_{current_time}.txt"

        # Create directory if not exists
        os.makedirs(os.path.dirname(output_path), exist_ok=True)

        # Running the testssl.sh script and saving the output
        command = ["/bin/bash", testssl_path, "--color", "0", "--fast", "--connect-timeout", "5", "--logfile", output_path, f"{address}:{port}"]

        try:
            result = subprocess.run(command, capture_output=True, check=True, text=True)
            print(colored(f"Service on {address}:{port}: Completed", "green"))
            print(colored(f"Results saved to {output_path}\n", "green"))
        except subprocess.CalledProcessError as e:
            log_error(f"Service on {address}:{port} encountered an error during testssl analysis. Error: {str(e)}\n{e.stderr}", errors_log_path)
            print(colored(f"Service on {address}:{port} encountered an error during testssl analysis. Error: {str(e)}\n{e.stderr}", "red"))

    if os.path.exists(errors_log_path):
        print(colored(f"\nDetailed errors have been logged to: '{errors_log_path}'.", "yellow"))

